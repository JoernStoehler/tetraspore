#!/bin/bash
# agent-monitor - Poll GitHub for @agent mentions and spawn agents
# Non-interactive, fast polling (10-15 seconds)
#
# WHY THIS EXISTS:
# - Enable remote agent triggering via GitHub comments ("@agent" mentions)
# - Support async development workflow - trigger agents while away from desk
# - Fire-and-forget design - no process management, manual cleanup later
#
# ARCHITECTURE DECISIONS:
# - Polling over webhooks (YAGNI) - simple, no network exposure needed
# - 10s interval - fast enough for UX, gentle on API limits
# - No process management - agents run independently, cleanup is manual
# - Stateless restarts - uses ~/.processed-mentions to avoid duplicates
#
# USAGE:
#   agent-monitor                    # Run in foreground
#   nohup agent-monitor &           # Run in background
#   
# TRIGGERS (in GitHub comments):
#   @agent                          # Use default model (sonnet)
#   @agent model:opus               # Use specific model
#   @agent --model gemini           # Alternative syntax
#
# FILES CREATED:
#   ~/agent-monitor.log             # Activity log
#   ~/.agent-monitor-processed      # Processed comment IDs
#   ~/agent-{issue}.jsonl          # Individual agent logs (JSON Lines format)
#   ../tetraspore-issue-{N}/       # Agent worktrees
#
# CLEANUP:
#   pkill -f agent-monitor          # Stop monitor
#   pkill -f "claude-code.*issue"   # Stop all agents
#   rm -rf ../tetraspore-issue-*    # Remove worktrees

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Configuration
POLL_INTERVAL=10  # seconds
LOOKBACK_TIME=600  # 10 minutes - to catch mentions during downtime
DEFAULT_MODEL="sonnet"  # Default model if not specified
REPO="JoernStoehler/tetraspore"  # GitHub repo
PROCESSED_FILE="$HOME/.agent-monitor-processed"
LOG_FILE="$HOME/agent-monitor.log"

# Function to log with timestamp
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
}

# Function to spawn agent non-interactively
spawn_agent() {
    local issue_num=$1
    local model=${2:-$DEFAULT_MODEL}
    local worktree_dir="/workspaces/tetraspore/../tetraspore-issue-$issue_num"
    local branch_name="issue-$issue_num"
    
    log "Spawning agent for issue #$issue_num with model $model"
    
    # Check if worktree already exists
    if [ -d "$worktree_dir" ]; then
        log "Worktree exists, starting agent with --continue"
        cd "$worktree_dir" || return 1
        
        # Start agent in background with --continue
        nohup agent --model "$model" --print --output-format json --continue \
            "/implement-issue $issue_num" \
            > "$HOME/agent-$issue_num.jsonl" 2>&1 &
        
        local pid=$!
        log "Agent started with PID $pid (continuing existing work)"
        return 0
    fi
    
    # Need to create new worktree
    cd /workspaces/tetraspore || return 1
    
    # Check if branch exists locally or remotely
    if git show-ref --verify --quiet "refs/heads/$branch_name" || \
       git ls-remote --heads origin "$branch_name" | grep -q "$branch_name"; then
        # Branch exists, create worktree from it
        log "Branch $branch_name exists, creating worktree"
        git worktree add "$worktree_dir" "$branch_name" 2>/dev/null || {
            # If fails, try with -f to override
            git worktree add -f "$worktree_dir" "$branch_name" 2>/dev/null || {
                log "ERROR: Failed to create worktree for existing branch"
                return 1
            }
        }
    else
        # Create new branch and worktree
        log "Creating new branch and worktree"
        git worktree add -b "$branch_name" "$worktree_dir" origin/main 2>/dev/null || {
            log "ERROR: Failed to create new worktree"
            return 1
        }
    fi
    
    # Setup environment in worktree
    cd "$worktree_dir" || return 1
    
    # Copy environment files
    cp /workspaces/tetraspore/.env .env 2>/dev/null || true
    cp /workspaces/tetraspore/.env.example .env.example 2>/dev/null || true
    
    # Create .env.local with unique ports
    local base_port=$((3000 + issue_num * 3))
    cat > .env.local << EOF
# Worktree-specific port configuration for issue-$issue_num
VITE_DEV_PORT=$base_port
VITE_PREVIEW_PORT=$((base_port + 1))
VITE_DEBUG_PORT=$((base_port + 2))
EOF
    
    # Install dependencies (suppress output)
    log "Installing dependencies..."
    npm install > /dev/null 2>&1 || {
        log "WARNING: npm install failed, continuing anyway"
    }
    
    # Start agent in background
    nohup agent --model "$model" --print --output-format json \
        "/implement-issue $issue_num" \
        > "$HOME/agent-$issue_num.jsonl" 2>&1 &
    
    local pid=$!
    log "Agent started with PID $pid (fresh start)"
    
    # Post comment on issue
    gh issue comment "$issue_num" -b "ðŸ¤– Agent spawned and working on this issue (model: $model, pid: $pid)

---
_Posted by AI Agent_" 2>/dev/null || true
    
    return 0
}

# Function to parse @agent mentions and extract parameters
parse_agent_mention() {
    local comment_body="$1"
    local model="$DEFAULT_MODEL"
    
    # Check for model specification like "@agent model:opus" or "@agent --model gemini"
    if echo "$comment_body" | grep -qiE "@agent\s+(model:|--model\s+)(opus|sonnet|gemini|flash)"; then
        model=$(echo "$comment_body" | grep -oiE "(model:|--model\s+)(opus|sonnet|gemini|flash)" | grep -oiE "(opus|sonnet|gemini|flash)")
    fi
    
    echo "$model"
}

# Initialize processed file if it doesn't exist
touch "$PROCESSED_FILE"

log "Agent monitor started (polling every ${POLL_INTERVAL}s)"
echo -e "${GREEN}Agent monitor is running. Press Ctrl+C to stop.${NC}"
echo "Monitoring repository: $REPO"
echo "Default model: $DEFAULT_MODEL"
echo "Log file: $LOG_FILE"
echo ""

# Main polling loop
while true; do
    # Calculate time window for API query (ISO 8601 format)
    if [[ "$OSTYPE" == "darwin"* ]]; then
        # macOS date command
        since_time=$(date -u -v-${LOOKBACK_TIME}S +"%Y-%m-%dT%H:%M:%SZ")
    else
        # Linux date command
        since_time=$(date -u -d "${LOOKBACK_TIME} seconds ago" +"%Y-%m-%dT%H:%M:%SZ")
    fi
    
    # Fetch recent comments with @agent mentions
    # Using GraphQL for more efficient querying
    mentions=$(gh api graphql -f query='
    query($owner: String!, $name: String!, $since: DateTime!) {
      repository(owner: $owner, name: $name) {
        issues(last: 100, filterBy: {since: $since}) {
          nodes {
            number
            state
            comments(last: 100) {
              nodes {
                id
                body
                createdAt
                author {
                  login
                }
              }
            }
          }
        }
      }
    }' -f owner="${REPO%/*}" -f name="${REPO#*/}" -f since="$since_time" \
    --jq '.data.repository.issues.nodes[] | 
           select(.state == "OPEN") | 
           . as $issue | 
           .comments.nodes[] | 
           select(.body | contains("@agent")) | 
           {issue: $issue.number, id: .id, body: .body, author: .author.login}' 2>/dev/null || true)
    
    # Also check pull request comments
    pr_mentions=$(gh api graphql -f query='
    query($owner: String!, $name: String!) {
      repository(owner: $owner, name: $name) {
        pullRequests(last: 100, states: [OPEN]) {
          nodes {
            number
            state
            comments(last: 100) {
              nodes {
                id
                body
                createdAt
                author {
                  login
                }
              }
            }
          }
        }
      }
    }' -f owner="${REPO%/*}" -f name="${REPO#*/}" \
    --jq '.data.repository.pullRequests.nodes[] | 
           . as $pr | 
           .comments.nodes[] | 
           select(.body | contains("@agent")) | 
           select(.createdAt > "'$since_time'") |
           {issue: $pr.number, id: .id, body: .body, author: .author.login}' 2>/dev/null || true)
    
    # Combine mentions
    all_mentions=$(echo -e "$mentions\n$pr_mentions" | grep -v '^$' || true)
    
    # Process each mention
    if [ -n "$all_mentions" ]; then
        echo "$all_mentions" | while IFS= read -r mention; do
            [ -z "$mention" ] && continue
            
            comment_id=$(echo "$mention" | jq -r '.id' 2>/dev/null || continue)
            issue_num=$(echo "$mention" | jq -r '.issue' 2>/dev/null || continue)
            comment_body=$(echo "$mention" | jq -r '.body' 2>/dev/null || continue)
            author=$(echo "$mention" | jq -r '.author' 2>/dev/null || echo "unknown")
            
            # Skip if issue number is invalid
            if [ -z "$issue_num" ] || [ "$issue_num" = "null" ]; then
                log "WARNING: Invalid issue number in mention"
                log "  Comment ID: $comment_id"
                log "  Author: $author"
                log "  Body preview: $(echo "$comment_body" | head -c 100)..."
                log "  Raw mention data: $mention"
                continue
            fi
            
            # Skip if already processed
            if grep -q "^$comment_id$" "$PROCESSED_FILE" 2>/dev/null; then
                continue
            fi
            
            # Parse model from comment
            model=$(parse_agent_mention "$comment_body")
            
            log "Found @agent mention in issue #$issue_num by $author (model: $model)"
            
            # Spawn agent
            if spawn_agent "$issue_num" "$model"; then
                # Mark as processed
                echo "$comment_id" >> "$PROCESSED_FILE"
                log "Successfully spawned agent for issue #$issue_num"
            else
                log "Failed to spawn agent for issue #$issue_num"
            fi
        done
    fi
    
    # Check for rate limit
    rate_remaining=$(gh api rate_limit --jq '.resources.core.remaining' 2>/dev/null || echo "unknown")
    if [ "$rate_remaining" != "unknown" ] && [ "$rate_remaining" -lt 100 ]; then
        log "WARNING: GitHub API rate limit low: $rate_remaining remaining"
        # Slow down polling if rate limit is low
        sleep 60
    else
        # Normal polling interval
        sleep $POLL_INTERVAL
    fi
done
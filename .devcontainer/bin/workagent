#!/bin/bash

# workagent - Git worktree and AI agent lifecycle management
#
# DESIGN PRINCIPLES:
# - Explicit over implicit: Fail fast on ambiguity
# - One branch = One agent = One lifecycle (no reuse)
# - Append-only context: Use --continue or start fresh
# - Clear ownership: Each worktree belongs to one agent forever
# - Two commands only: prepare (setup) and run (execute)
#
# USAGE:
#   workagent prepare --branch BRANCH [--from SOURCE]
#   workagent run --branch BRANCH [--continue] --message MESSAGE [--model MODEL]
#   workagent status
#   workagent attach --branch BRANCH
#   workagent help

set -e

# Configuration
AGENT_CMD="${AGENT_CMD:-agent}"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Helper functions
error() {
    echo -e "${RED}✗ Error: $1${NC}" >&2
    exit 1
}

success() {
    echo -e "${GREEN}✓ $1${NC}"
}

info() {
    echo -e "${YELLOW}→ $1${NC}"
}

detail() {
    echo -e "  ${BLUE}$1${NC}"
}

# Slugify branch name for directory
slugify() {
    echo "$1" | sed -e 's/[^a-zA-Z0-9._-]/-/g' | sed -e 's/--*/-/g' | sed -e 's/^-//;s/-$//'
}

# Check if tmux is available
check_tmux() {
    if ! command -v tmux &> /dev/null; then
        error "tmux is required but not installed. In devcontainer it should be pre-installed."
    fi
}

# Prepare worktree and environment
prepare_worktree() {
    local branch="$1"
    local from="$2"
    
    [ -z "$branch" ] && error "Branch name required. Usage: workagent prepare --branch BRANCH [--from SOURCE]"
    
    local slug=$(slugify "$branch")
    local worktree_dir="../tetraspore-$slug"
    
    info "Preparing worktree for branch: $branch"
    
    # Check prerequisites
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        error "Not in a git repository"
    fi
    
    # Check if branch exists
    local branch_exists=false
    if git show-ref --verify --quiet "refs/heads/$branch"; then
        branch_exists=true
    fi
    
    # Determine source branch
    if [ "$branch_exists" = true ]; then
        # Branch exists, no --from needed
        if [ -n "$from" ]; then
            detail "Warning: --from ignored because branch '$branch' already exists"
        fi
    else
        # Branch doesn't exist, need to create
        if [ -z "$from" ]; then
            # Check if we're in main worktree
            if [ "$(git branch --show-current)" = "main" ]; then
                from="main"
                detail "Creating new branch from main (implicit)"
            else
                error "Not in main worktree. Specify source branch with --from\nCurrent branch: $(git branch --show-current)\nExample: workagent prepare --branch $branch --from main"
            fi
        else
            # Verify source branch exists
            if ! git show-ref --verify --quiet "refs/heads/$from"; then
                error "Source branch '$from' does not exist\nAvailable branches: $(git branch -a | grep -v 'HEAD' | sed 's/^[* ]*//' | head -10 | tr '\n' ' ')"
            fi
        fi
    fi
    
    # Check for uncommitted changes warning
    if ! git diff-index --quiet HEAD -- 2>/dev/null; then
        detail "Warning: Uncommitted changes in current worktree won't be in new worktree"
    fi
    
    # Create worktree
    if [ -d "$worktree_dir" ]; then
        info "Worktree already exists at $worktree_dir"
        # Verify it's the right branch
        local current_branch=$(git -C "$worktree_dir" branch --show-current 2>/dev/null || echo "unknown")
        if [ "$current_branch" != "$branch" ]; then
            error "Worktree exists but is on branch '$current_branch', expected '$branch'"
        fi
    else
        info "Creating worktree at $worktree_dir"
        if [ "$branch_exists" = true ]; then
            git worktree add "$worktree_dir" "$branch"
            detail "Checked out existing branch: $branch"
        else
            git worktree add -b "$branch" "$worktree_dir" "$from"
            detail "Created new branch: $branch from $from"
        fi
        success "Worktree created"
    fi
    
    # Copy environment files
    info "Setting up environment"
    if [ -f .env ]; then
        if [ ! -f "$worktree_dir/.env" ] || [ .env -nt "$worktree_dir/.env" ]; then
            cp .env "$worktree_dir/.env"
            detail "Copied .env file"
        fi
    else
        detail "Warning: No .env file found in main worktree"
    fi
    
    # Set up ports using shared allocation registry
    if [ ! -f "$worktree_dir/.env.local" ]; then
        # Create shared ports registry if needed
        local SHARED_DIR="/workspaces/.agent-shared"
        local PORTS_FILE="$SHARED_DIR/allocated-ports"
        mkdir -p "$SHARED_DIR"
        [ ! -f "$PORTS_FILE" ] && echo "# Branch:Port" > "$PORTS_FILE"
        
        # Find next available port range (3 consecutive ports)
        local port=3010
        while true; do
            # Check if any of the 3 ports are in use
            local port_in_use=false
            for offset in 0 1 2; do
                if lsof -Pi :$((port + offset)) -sTCP:LISTEN -t >/dev/null 2>&1; then
                    port_in_use=true
                    break
                fi
                if grep -q ":$((port + offset))$" "$PORTS_FILE" 2>/dev/null; then
                    port_in_use=true
                    break
                fi
            done
            
            if [ "$port_in_use" = false ]; then
                # Allocate these ports
                echo "$branch:$port" >> "$PORTS_FILE"
                break
            fi
            
            # Try next range
            port=$((port + 3))
            if [ $port -gt 4000 ]; then
                error "No available ports found (searched 3010-4000)"
            fi
        done
        
        cat > "$worktree_dir/.env.local" << EOF
# Auto-generated ports for $branch
VITE_DEV_PORT=$port
VITE_PREVIEW_PORT=$((port + 1))
VITE_DEBUG_PORT=$((port + 2))
EOF
        detail "Allocated ports: dev=$port, preview=$((port + 1)), debug=$((port + 2))"
    fi
    
    # Install dependencies
    info "Installing dependencies"
    (cd "$worktree_dir" && npm install --quiet)
    success "Dependencies installed"
    
    # Create .agent directory
    mkdir -p "$worktree_dir/.agent"
    echo "$branch" > "$worktree_dir/.agent/branch"
    date -u +"%Y-%m-%dT%H:%M:%SZ" > "$worktree_dir/.agent/prepared"
    
    # Create persistent logs directory
    local logs_dir="/workspaces/.agent-shared/logs/$branch"
    mkdir -p "$logs_dir"
    
    success "Worktree prepared successfully!"
    echo ""
    echo "Next steps:"
    echo "  1. Create task file (optional):"
    echo "     ${BLUE}Write('../tetraspore-$slug/AGENT_BRANCH_TASK.md', 'Task description...')${NC}"
    echo ""
    echo "  2. Run agent:"
    echo "     ${BLUE}workagent run --branch $branch --message \"Your instructions here\"${NC}"
}

# Run agent (new or continue)
run_agent() {
    local branch="$1"
    local continue_flag="$2"
    local message="$3"
    local model="$4"
    
    [ -z "$branch" ] && error "Branch name required"
    [ -z "$message" ] && error "Message required. Use --message \"...\" or pipe to stdin"
    
    check_tmux
    
    local slug=$(slugify "$branch")
    local session_name="agent-$slug"
    local worktree_dir="../tetraspore-$slug"
    
    # Check if worktree exists
    if [ ! -d "$worktree_dir" ]; then
        error "Worktree not found. Run: workagent prepare --branch $branch"
    fi
    
    # Check if this is a continuation by looking at agent's status file
    local has_history=false
    if [ -f "$worktree_dir/.agent/stopped" ]; then
        has_history=true
    fi
    
    # Validate --continue flag
    if [ "$continue_flag" = true ]; then
        if [ "$has_history" = false ]; then
            error "Cannot use --continue: No previous agent run found"
        fi
    else
        if [ "$has_history" = true ]; then
            error "Previous agent run detected. Use --continue to resume conversation"
        fi
    fi
    
    # Check if already running
    if tmux has-session -t "$session_name" 2>/dev/null; then
        local status="UNKNOWN"
        if tmux list-clients -t "$session_name" 2>/dev/null | grep -q .; then
            status="ATTACHED"
        else
            status="RUNNING"
        fi
        error "Agent already running for branch $branch (status: $status)\nUse: workagent attach --branch $branch"
    fi
    
    info "Running agent for branch: $branch"
    detail "Working directory: $worktree_dir"
    detail "Continue: $continue_flag"
    if [ -n "$model" ]; then
        detail "AI model: $model"
    fi
    
    # Build agent command
    local agent_args="--print --verbose --output-format stream-json"  # Stream all actions
    if [ "$continue_flag" = true ]; then
        agent_args="$agent_args --continue"
    fi
    if [ -n "$model" ]; then
        agent_args="$agent_args --model $model"
    fi
    
    # Update agent metadata
    echo "RUNNING" > "$worktree_dir/.agent/status"
    date -u +"%Y-%m-%dT%H:%M:%SZ" > "$worktree_dir/.agent/last_run"
    
    # Create run script
    local run_script="$worktree_dir/.agent/run.sh"
    cat > "$run_script" << EOF
#!/bin/bash
cd "$worktree_dir"
echo "=================================="
echo "Agent: $branch"
echo "Time: $(date)"
echo "Continue: $continue_flag"
echo "Model: ${model:-default}"
echo "=================================="
echo ""

# Run agent with message (write to persistent log only)
$AGENT_CMD $agent_args "$message" 2>&1 | tee -a /workspaces/.agent-shared/logs/$branch/session.log

# Update status when done
echo "STOPPED" > .agent/status
date -u +"%Y-%m-%dT%H:%M:%SZ" > .agent/stopped
EOF
    chmod +x "$run_script"
    
    # Start in tmux
    tmux new-session -d -s "$session_name" -c "$worktree_dir" "$run_script"
    
    success "Agent started"
    echo ""
    echo "To monitor:"
    echo "  ${BLUE}workagent attach --branch $branch${NC}    # Watch output"
    echo "  ${BLUE}workagent status${NC}                      # Check all agents"
    echo "  ${BLUE}mail inbox --for main${NC}                 # Check messages"
}

# Attach to running agent
attach_agent() {
    local branch="$1"
    
    [ -z "$branch" ] && error "Branch name required"
    
    check_tmux
    
    local slug=$(slugify "$branch")
    local session_name="agent-$slug"
    
    if ! tmux has-session -t "$session_name" 2>/dev/null; then
        error "No agent running for branch $branch"
    fi
    
    info "Attaching to agent session: $session_name"
    echo "Press Ctrl+B then D to detach"
    echo ""
    sleep 1
    
    # Attach to tmux
    tmux attach-session -t "$session_name"
}

# Show status of all agents
show_status() {
    check_tmux
    
    info "Agent Status"
    echo ""
    
    # Header
    printf "%-25s %-12s %-20s %s\n" "BRANCH" "STATUS" "LOG ACTIVITY" "LAST ACTION"
    echo "--------------------------------------------------------------------------------"
    
    # Check all worktrees
    local found=0
    for worktree in ../tetraspore-*; do
        if [ -d "$worktree/.agent" ] && [ -f "$worktree/.agent/branch" ]; then
            local branch=$(cat "$worktree/.agent/branch")
            local slug=$(slugify "$branch")
            local session_name="agent-$slug"
            local status="STOPPED"
            local log_activity=""
            local last_action=""
            
            # Check if running
            if tmux has-session -t "$session_name" 2>/dev/null; then
                status="RUNNING"
            elif [ -f "$worktree/.agent/status" ]; then
                status=$(cat "$worktree/.agent/status")
            fi
            
            # Get log activity for running agents
            local shared_log="/workspaces/.agent-shared/logs/$branch/session.log"
            if [ -f "$shared_log" ]; then
                # Get log file modification time
                local log_mod_time=$(stat -c %Y "$shared_log" 2>/dev/null || stat -f %m "$shared_log" 2>/dev/null || echo 0)
                local current_time=$(date +%s)
                local minutes_ago=$(( (current_time - log_mod_time) / 60 ))
                
                if [ $minutes_ago -lt 1 ]; then
                    log_activity="Active now"
                elif [ $minutes_ago -lt 5 ]; then
                    log_activity="${minutes_ago}min ago"
                elif [ $minutes_ago -lt 15 ]; then
                    log_activity="${minutes_ago}min ago"
                elif [ $minutes_ago -lt 60 ]; then
                    log_activity="${minutes_ago}min ago ⚠️"
                else
                    log_activity="$(( minutes_ago / 60 ))h ago ⚠️"
                fi
                
                # Get last meaningful action from log
                if [ "$status" = "RUNNING" ]; then
                    # Look for tool calls in stream-json output
                    last_action=$(tail -100 "$shared_log" 2>/dev/null | grep -E '"tool_name":|"type":"tool_use"' | tail -1 | sed 's/.*"tool_name":"\([^"]*\)".*/\1/' | cut -c1-30)
                    if [ -z "$last_action" ]; then
                        last_action="Thinking..."
                    fi
                fi
            else
                log_activity="No log"
            fi
            
            printf "%-25s %-12s %-20s %s\n" "$branch" "$status" "$log_activity" "$last_action"
            ((found++)) || true  # Prevent exit on arithmetic that evaluates to 0
        fi
    done
    
    if [ $found -eq 0 ]; then
        echo "No agents found"
    fi
    
    echo ""
    detail "Use 'workagent attach --branch BRANCH' to monitor a running agent"
    
    # Always return success for status command
    return 0
}

# Show help
show_help() {
    echo "workagent - Git worktree and AI agent lifecycle management"
    echo ""
    echo "Commands:"
    echo "  prepare  --branch BRANCH [--from SOURCE]      Set up worktree and environment"
    echo "  run      --branch BRANCH --message MSG        Run agent with message"
    echo "           [--continue] [--model MODEL]          (--continue required if agent has history)"
    echo "  status                                         Show all agents and their status"
    echo "  attach   --branch BRANCH                      Connect to running agent output"
    echo "  help                                           Show this help"
    echo ""
    echo "Model options:"
    echo "  --model opus           Claude Opus 4 (deep intelligence, slower)"
    echo "  --model sonnet         Claude Sonnet 4 (fast, efficient)"
    echo "  --model gemini         Gemini 2.5 Pro (advanced reasoning)"
    echo "  --model flash          Gemini 2.5 Flash (fast responses)"
    echo "  (default: agent command default - Claude)"
    echo ""
    echo "Workflow example:"
    echo "  ${BLUE}# Prepare new feature branch${NC}"
    echo "  workagent prepare --branch feat/auth"
    echo "  "
    echo "  ${BLUE}# Create task file (optional)${NC}"
    echo "  Write('../tetraspore-feat-auth/AGENT_BRANCH_TASK.md', 'Implement auth...')"
    echo "  "
    echo "  ${BLUE}# Start agent${NC}"
    echo "  workagent run --branch feat/auth --message \"Read AGENT_BRANCH_TASK.md and implement\""
    echo "  "
    echo "  ${BLUE}# Continue after agent stops${NC}"
    echo "  workagent run --branch feat/auth --continue --message \"Add tests for the auth module\""
    echo "  "
    echo "  ${BLUE}# Review workflow${NC}"
    echo "  workagent prepare --branch review/auth-v1 --from feat/auth"
    echo "  workagent run --branch review/auth-v1 --message \"Review code in this branch\""
    echo ""
    echo "Design principles:"
    echo "  • One branch = One agent = One lifecycle (no agent reuse)"
    echo "  • Explicit --continue required to resume vs start fresh"
    echo "  • Agents run with --print mode and terminate naturally"
    echo "  • Clear ownership: worktree belongs to one agent forever"
}

# Main command dispatcher
case "${1:-help}" in
    prepare)
        shift
        branch=""
        from=""
        while [[ $# -gt 0 ]]; do
            case $1 in
                --branch) branch="$2"; shift 2 ;;
                --from) from="$2"; shift 2 ;;
                *) error "Unknown option: $1" ;;
            esac
        done
        prepare_worktree "$branch" "$from"
        ;;
        
    run)
        shift
        branch=""
        message=""
        model=""
        continue_flag=false
        while [[ $# -gt 0 ]]; do
            case $1 in
                --branch) branch="$2"; shift 2 ;;
                --message) message="$2"; shift 2 ;;
                --model) model="$2"; shift 2 ;;
                --continue) continue_flag=true; shift ;;
                -) message=$(cat); shift ;;
                *) error "Unknown option: $1" ;;
            esac
        done
        run_agent "$branch" "$continue_flag" "$message" "$model"
        ;;
        
    attach)
        shift
        branch=""
        while [[ $# -gt 0 ]]; do
            case $1 in
                --branch) branch="$2"; shift 2 ;;
                *) error "Unknown option: $1" ;;
            esac
        done
        attach_agent "$branch"
        ;;
        
    status)
        show_status
        ;;
        
    help|--help|-h)
        show_help
        ;;
        
    *)
        error "Unknown command: $1\nRun 'workagent help' for usage"
        ;;
esac